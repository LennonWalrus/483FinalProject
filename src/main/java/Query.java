import edu.stanford.nlp.simple.Sentence;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.core.StopAnalyzer;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.queryparser.classic.ParseException;
import org.apache.lucene.queryparser.classic.QueryParser;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.ScoreDoc;
import org.apache.lucene.search.TopDocs;
import org.apache.lucene.store.FSDirectory;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Scanner;
//this program reads questions from question text file formats them and then uses them to create lucene queries to get MRR Scores
public class Query {
    private static FSDirectory index;// saved lucene index
    private static Analyzer analyzer;
    static ArrayList<String> answers = new ArrayList<>();// list of answers to questions
    static ArrayList<String> foundAnswers = new ArrayList<>();//list of answers generated by search
    static int topD = 1;// int for top documents to be scored

    //runs program and checks for arguments
    public static void main(String[] args) {
        //checks to see if there are proper arguments for the program
        if(args.length == 0 || (args.length == 1 && isNumeric(args[0]))){
            if(args.length != 0){//when there is a numeric argument
                topD = Integer.parseInt(args[0]);//we change topD to it
            }
            //otherwise we default to the topD = 1 which is already set
        }
        else {//print error and quit if no proper arguments
            System.out.println("Please enter no arguments for top document or a number x as a argument documents for top x documents");
            System.exit(1);
        }
        grabIndex();//call grab index to find index in resources and set
        ArrayList<String> queries = genQueries(Paths.get("src/main/resources/questions.txt"));//generate question and answer strings from question txt
        queries = queryStemm(queries);// make the question/hint strings into lemmas
        luceneAnswers(queries);//use lemmatized hints to gen queries to calc MRR

    }

    //grabs the created index from index.java
    private static void grabIndex(){
        try {//search for the index in resources and set it
            index = FSDirectory.open(Paths.get("src/main/resources/wiki.lucene"));
        } catch (IOException e) {
            e.printStackTrace();
        }
        analyzer = new StandardAnalyzer();//set the analayzer as well
    }

    //loops through the txt in questions txt and generates category/hints and answers for each question
    private static ArrayList<String> genQueries(Path questions){
        ArrayList<String> queries = new ArrayList<>();//list of hints/category
        File qTxt = new File(String.valueOf(questions));//grab file path for questions txt file
        Scanner inputScanner = null;
        try {//set up scanner for question txt
            inputScanner = new Scanner(qTxt);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        while(inputScanner.hasNext()){//looping though question file
            String query = "";//for query
            String answer = "";//for answer
            //query += inputScanner.nextLine() +" ";//grabs category
            inputScanner.nextLine(); //to be swapped with above if you dont want to use category
            query += inputScanner.nextLine();//grabs hint
            answer+= inputScanner.nextLine().toLowerCase();//grabs answer
            inputScanner.nextLine();//skip blank line after
            queries.add(query);//add the query to queries
            answers.add(answer);//add the one answer

            //System.out.println(query);
            //System.out.println(answer);
        }
        return queries;
    }

    //method to stem generated query strings
    private static ArrayList<String> queryStemm(ArrayList<String> old){
        ArrayList<String> stemed = new ArrayList<>();// list of stemmed queries
        for(String pre: old){//looping though each query string
                stemed.add(LineCleaner(pre));//add stemmed string to stemmed queries
            }
        return stemed;
    }

    //method to remove punctuation and stop words from query strings and stemming the strings as well
    private static String LineCleaner(String line){
        String ret = " ";
        String[] tokens = line.split("[!.,?;\\s]+");//split the line into tokens
        for(String s : tokens){//for each token
            String token = s;

            while(token.startsWith("(") || token.startsWith("=") || token.startsWith("\"")){//remove these symbols from start of string untill there are no more of them
                token = token.substring(1,token.length());
            }
            //while the line ends with any of the below punctuation or symbols or a s
            //removes s for stemming
            while (token.endsWith(",") || token.endsWith(")") || token.endsWith("?") || token.endsWith(".") || token.endsWith("!") || token.endsWith(";") || token.endsWith(":")|| token.endsWith("=") || token.endsWith("s")|| token.endsWith("\"")){
                token = token.substring(0, token.length()-1);//remove last character
            }
            //rmoving trailing ed for stemming purposes
            if(token.endsWith("ed")){
                token = token.substring(0,token.length()-2);
            }
            //remove trailing ing for stemming purposes
            if(token.endsWith("ing")){
                token = token.substring(0,token.length()-3);
            }
            //remove -s from middle of token
            while(token.contains("-")){
                token = token.substring(0,token.indexOf("-")) + token.substring(token.indexOf("-")+1);
            }
            //remove (s from middle of token
            while(token.contains("(")){
                token = token.substring(0,token.indexOf("(")) + token.substring(token.indexOf("(")+1);
            }
            //remove " from middle of token
            while(token.contains("\"")){
                token = token.substring(0,token.indexOf("\"")) + token.substring(token.indexOf("\"")+1);
            }// skip if just comma
            if(token.equals(","))
                continue;
            //skip stop words
            if(StopAnalyzer.ENGLISH_STOP_WORDS_SET.contains(token.toLowerCase())) {
                continue;
            }


            ret += token.toLowerCase() + " ";// add resulting token to return string with space
        }
        return ret.substring(0,ret.length()-1);// return string without final space
    }

    //method to generate lucene query from stemmed strings and then use query to gen MRR Scores for each question
    private static void luceneAnswers(ArrayList<String> queries){
        int count = -1;//counter for answers list
        float overallScore = 0;//overall MRR Score
        for(String quest: queries) {//loop through stemmed queries
            count++;//up the answer list count
            String qstr = "content:";//start query stirng with content:
            System.out.println(quest);//print the stemmed query without the ORs
            String[] tokens = quest.split("[!.,?;\\s]+");//split the stemedquery
            for(String token: tokens){//for each
                if(token.equals(""))//if empty skip
                    continue;
                qstr += token + " OR content:";//other wise add token with trailing or and content to set up for next token
            }
            qstr = qstr.substring(0, qstr.length()-12);//once all lemmas added remove final trailing lemma.

            //System.out.println(qstr);
            //declare all needed lucene variables to answer query and get top docs
            org.apache.lucene.search.Query q = null;
            IndexReader reader = null;
            IndexSearcher searcher = null;
            TopDocs docs = null;
            int hitsPerPage = 10;//make hits per page match topD
            try {
                q = new QueryParser("content", analyzer).parse(qstr);// generate query using query parser and our or string
                reader = DirectoryReader.open(index);//create reader on found lucene index
                //System.out.println(reader.numDocs());
                searcher = new IndexSearcher(reader);// set searcher with
                docs = searcher.search(q, hitsPerPage);// set top docs with query and hits per page on searcher
                ScoreDoc[] hits = docs.scoreDocs;//grab hits using score docs
                //System.out.println(hits.length);
                for(int i = 0; i< topD; i++ ){//loop through topD docs and print the topD results
                    System.out.println("result " + (i+1) + ": \"" +searcher.doc(hits[i].doc).get("title") +"\"" );
                }
                System.out.println( "real: \"" +answers.get(count) +"\"");//print the actual title answer to question
                float score = docMRRCalc(hits,count,searcher);//generate the scre using docMRRCalc method
                overallScore += score;//add the score to the overall score
                System.out.println("MRR Score " +score);//print MRR score for question
                System.out.println();//print empty
                foundAnswers.add(searcher.doc(hits[0].doc).get("title"));//add answer to found answers
            } catch (ParseException | IOException e) {
                e.printStackTrace();
            }

        }
        float MRR = overallScore/(float) queries.size();//calc overall score by getting sum and diving by the total number of questions
        System.out.println("Using Top " + topD +" documents found...");
        System.out.println("Overall MRR is " + MRR);//print overall MRR
    }

    //method used to calculate MRR for a given question given the top hits
    private static float docMRRCalc(ScoreDoc[] hits, int count,IndexSearcher searcher ){
        for(int i = 0; i< 10; i++){//loop thorugh topD documents
            try {
                //if found
                if(searcher.doc(hits[i].doc).get("title").equals(answers.get(count))){
                    return (float)1/(float)(i+1);//return 1/position of found answer in rank starting at 1
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return 0;//reciprocal rank is 0 if not found in topD documents
    }

    //method to check if string is a number
    public static boolean isNumeric(String str) {
        try {//if you can parse as a double its a number return true
            Double.parseDouble(str);
            return true;
            //else return false
        } catch(NumberFormatException e){
            return false;
        }
    }


}
